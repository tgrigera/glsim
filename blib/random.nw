% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% random.nw -- class interface to GSL random number generators and
%              distributions
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013, 2014
% by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.

@ \section{Random numbers}

Random numbers are not needed in all simulations, but they are so
frequently used that we provide an interface integrated into \glsim's
conventions.  \glsim\ uses the GSL's generators.  These classes are
just a C++ wrapper around the GSL interface, which is not hard since
the GSL design is object-oriented.  We use a class to hold one of the
available generators, and another set that represent random number
distributions.  These provide the actual numbers to be used in the
simulation, but rely on (pseudo)random numbers provided by
[[random_number_generator]].

%'

<<random.hh>>=
#ifndef _RANDOM_HH_
#define _RANDOM_HH_

#include <fstream>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <boost/serialization/version.hpp>
#include <boost/serialization/binary_object.hpp>

#include <glsim/exception.hh>

namespace glsim {
<<distribution_base declaration>>
<<generator declaration>>
<<distribution_base inline methods>>
<<uniform_integer declaration>>
<<uniform_real declaration>>
<<gaussian_distribution delcaration>>
<<exponential_declaration>>
<<lognormal declaration>>
<<levy declaration>>
<<spherical3d declaration>>
}
<<out-of-namespace-declarations>>

#endif /* _RANDOM_HH_ */

<<random.cc>>=
#include <iostream>

#include <glsim/random.hh>

namespace glsim {
<<generator methods>>
}

@ \subsection{Random number generator}

A GSL random number generator (RNG) is created by creating an instance
of this class.  Normally only one [[random_number_generator]] object
will exist, which can be shared among many random distributions.  The
internal state of a generator can be saved to a file and later
restored, with the simple interface or through Boost::serialize.  We
give here methods to access the raw generator output, but normally the
random numbers will be obtained through one of the distributions
defined below.

<<generator declaration>>=
class random_number_generator {
public:
  random_number_generator(const gsl_rng_type *type,const unsigned long seed=0);
  random_number_generator(random_number_generator&);
  random_number_generator& operator=(random_number_generator&);
  ~random_number_generator();
  void set_seed(const unsigned long seed);
  int save(FILE *f);
  int load(FILE *f);
  void save(std::ostream&);
  void load(std::istream&);

  unsigned long raw();
  unsigned long min() const;
  unsigned long max() const;
  unsigned long range() const;

private:
  gsl_rng *generator;

  friend rdbase_ulong;
  friend rdbase_double;

  template <typename Ar>
  void serialize(Ar& ar,const unsigned int version) const;
  friend class boost::serialization::access;
}  ;

@ The [[friend rdbase]] declarations above refer to
[[random_distribution_base]] specializations that are defined below.
The last friend is needed to give [[Boost::serialization]] acces to
the serialization functions.  We finish the declaration by setting the
class version number to keep track of changes for serialization.  This
declaration needs to be in the global namespace.

<<out-of-namespace-declarations>>=
BOOST_CLASS_VERSION(glsim::random_number_generator,0)


@ \paragraph{Implementation.}  Creation and destruction simply involve
calling the corresponding [[gsl_rng]] functions.  Copying is
complicated and not immediatly useful, not supported at this time.

<<generator methods>>=
random_number_generator::
random_number_generator(const gsl_rng_type *type,const unsigned long seed) :
  generator(0)
{
  generator=gsl_rng_alloc(type);
  gsl_rng_set(generator,seed);
}

random_number_generator::random_number_generator(random_number_generator& r)
{
  throw glsim::Unimplemented("copying of random number generator not allowed");
}

random_number_generator& 
random_number_generator::operator=(random_number_generator&)
{
  throw glsim::Unimplemented("copying of random number generator not allowed");
}

random_number_generator::~random_number_generator()
{
  gsl_rng_free(generator);
  generator=0;
}

@ Setting the seed and saving/loading to file are immediate,
saving/loading to a stream are implemented by requesting a binary copy
of the generator state.

<<generator declaration>>=
inline void random_number_generator::set_seed(const unsigned long seed)
{
  gsl_rng_set(generator,seed);
}

inline int random_number_generator::save(FILE *f)
{
  return gsl_rng_fwrite(f,generator);
}

inline int random_number_generator::load(FILE *f)
{
  return gsl_rng_fread(f,generator);
}

<<generator methods>>=
void random_number_generator::save(std::ostream& os)
{
  void *state=gsl_rng_state(generator);
  os.write((char*) state,gsl_rng_size(generator));
}

void random_number_generator::load(std::istream& is)
{
  void *state=gsl_rng_state(generator);
  is.read((char*) state,gsl_rng_size(generator));
}

@ [[raw()]] returns an integer in the range [[[min()]],[[max()]]].

<<generator declaration>>=
inline unsigned long random_number_generator::raw()
{
  return gsl_rng_get(generator);
}

inline unsigned long random_number_generator::min() const
{
  return gsl_rng_min(generator);
}

inline unsigned long random_number_generator::max() const
{
  return gsl_rng_max(generator);
}

inline unsigned long random_number_generator::range() const
{
  return gsl_rng_max(generator)-gsl_rng_min(generator);
}

@ Finally, the serialization methods allow alternative interface to
state saving, through the Boost::serialization library.

<<generator declaration>>=
template <typename Ar>
void random_number_generator::serialize(Ar& ar,const unsigned int ver) const
{
  boost::serialization::binary_object bo(gsl_rng_state(generator),gsl_rng_size(generator));
  ar & bo;
}

@ \subsection{Random distributions}

The following classes provide random numbers distributed according to
different forms, based on the numbers provided by a
[[random_number_generator]] object.

The following is the base class for all distributions.  The way to
obtain a random number will be through [[operator()()]], which is pure
virtual at this level.  We provide access to the raw generator's
function here for convenience.

%'
<<distribution_base declaration>>=
class random_number_generator;

template <typename ranT>
class random_distribution_base {
public:
  random_distribution_base(random_number_generator &rng);
  virtual ranT operator()()=0;

  unsigned long raw();
  unsigned long min() const;
  unsigned long max() const;
  unsigned long range() const;

protected:
  gsl_rng                 *generator;
  random_number_generator *glsim_generator;
} ;

typedef random_distribution_base<double> rdbase_double;
typedef random_distribution_base<unsigned long> rdbase_ulong;

<<distribution_base inline methods>>=
template <typename ranT> inline random_distribution_base<ranT>::
random_distribution_base(random_number_generator &r) :
  generator(r.generator),
  glsim_generator(&r)
{}

template <typename ranT>
unsigned long random_distribution_base<ranT>::raw()
{
  return glsim_generator->raw();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::min() const {
  return glsim_generator->min();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::max() const {
  return glsim_generator->max();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::range() const {
  return glsim_generator->range();
}




@ \subsubsection{Uniform random numbers}

These classes return real and integer random numbers with a uniform
distribution.  The first class represents uniformly-distributed
integer ([[unsigned long]]) numbers from 0 to a given integer.

<<uniform_integer declaration>>=
class uniform_integer : public rdbase_ulong {
public:
  uniform_integer(random_number_generator&,unsigned long);
  unsigned long operator()();

private:
  unsigned long gsl_m;
} ;

@ The range will be $[0,\ldots,m-1]$, where $m$ is specified on construction:

<<uniform_integer declaration>>=
inline
uniform_integer::uniform_integer(random_number_generator &rng,unsigned long m) :
  random_distribution_base(rng),
  gsl_m(m)
{}

inline unsigned long uniform_integer::operator()()
{
  return gsl_rng_uniform_int(generator,gsl_m);
}

@ And now a uniformly-distributed real numbers in the range
$[a,b)$ ($b$ excluded).

<<uniform_real declaration>>=
class uniform_real : public rdbase_double {
public:
  uniform_real(random_number_generator&,double a=0,double b=1);
  double operator()();

private:
  double a,range;
} ;

inline uniform_real::uniform_real(random_number_generator &r,double a,double b) :
  random_distribution_base(r),
  a(a)
{
  range=b-a;
}

inline double uniform_real::operator()()
{
  return a+range*gsl_rng_uniform(generator);
}

@ \subsubsection{Gaussian distribution}

This class uses GSL RNG to return a real ([[double]]) distributed
according to
$$
p(x)\, dx = {1 \over \sqrt{2 \pi \sigma^2}} \exp (-x^2 / 2\sigma^2) \,dx.
$$


<<gaussian_distribution delcaration>>=
class gaussian_distribution : public rdbase_double {
public:
  gaussian_distribution(random_number_generator &r,double sigma=1.,
			double mean=0.);
  double operator()();

private:
  double sigma,mean;
} ;

inline gaussian_distribution::gaussian_distribution(random_number_generator &r,
						    double sigma_,double mean_) :
  random_distribution_base(r),
  sigma(sigma_),
  mean(mean_)
{}

inline double gaussian_distribution::operator()()
{
  return mean + gsl_ran_gaussian(generator,sigma);
}

@ \subsubsection{Exponential distribution}

The exponential distribution is defined by
$$
          p(x)\, dx = {1 \over \mu} \exp(-x/\mu)\, dx.
$$

<<exponential_declaration>>=
class exponential_distribution : public random_distribution_base<double> {
public:
  exponential_distribution(random_number_generator &r,double mu);
  double operator()();

private:
  double mu;
} ;

inline
exponential_distribution::exponential_distribution(random_number_generator &r,
						   double mu_) :
  random_distribution_base(r),
  mu(mu_)
{}

inline double exponential_distribution::operator()()
{
  return gsl_ran_exponential(generator,mu);
}

@ \subsubsection{Log-normal distribution}

The log-normal distribution is
$$
p(x)\, dx = {1 \over x \sqrt{2 \pi \sigma^2} } 
          \exp\left[-\frac{(\ln x - \zeta)^2}{2 \sigma^2}\right] \, dx.
$$

<<lognormal declaration>>=
class lognormal_distribution : public rdbase_double {
public:
  lognormal_distribution(random_number_generator &r,double zeta,double sigma);
  double operator()();

private:
  double zeta,sigma;
} ;

inline lognormal_distribution::lognormal_distribution(random_number_generator &r,
						      double zeta_,
						      double sigma_) :
  random_distribution_base(r),
  zeta(zeta_),
  sigma(sigma_)
{}

inline double lognormal_distribution::operator()()
{
  return gsl_ran_lognormal(generator,zeta,sigma);
}

@ \subsubsection{Levy distribution}

This distribution is defined by
$$
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c t|^\alpha).
$$

<<levy declaration>>=
class levy_distribution : public rdbase_double {
public:
  levy_distribution(random_number_generator &r,double C,double alpha);
  double operator()();

private:
  double C,alpha;
} ;

inline levy_distribution::levy_distribution(random_number_generator &r,double C_,
					    double alpha_):
  random_distribution_base(r),
  C(C_), alpha(alpha_)
{}

inline double levy_distribution::operator()()
{
  return gsl_ran_levy(generator,C,alpha);
}


@ \subsubsection{Spherical distribution}

This returns a random vector with tip on the unit sphere (random
direction in three dimensions).

<<spherical3d declaration>>=
class spherical3d_distribution : public rdbase_double {
public:
  spherical3d_distribution(random_number_generator &r) :
  random_distribution_base(r) {}

  double operator()();
  void operator()(double *r);
} ;


inline double spherical3d_distribution::operator()()
{
  throw glsim::Invalid_operation("operator() requires 3 arguments in spherical3d_distribution");
}

inline void spherical3d_distribution::operator()(double *r)
{
  gsl_ran_dir_3d(generator,r,r+1,r+2);
}



