% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% random.nw -- class interface to GSL random number generators and
%              distributions
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013, 2014
% by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.

@ \section{Random numbers}

Random numbers are not needed in all simulations, but they are so
frequently used that we provide an interface integrated into \glsim's
conventions.  \glsim\ uses the GSL's generators.  These classes are
basically a C++ wrapper around the GSL interface, which is not hard since
the GSL design is object-oriented.  We use a class to hold one of the
available generators, and another set that represent random number
distributions.  These provide the actual numbers to be used in the
simulation, but rely on (pseudo)random numbers provided by
[[random_number_generator]].

The design of the classes allows to define a random distribution
object (descended from [[distribution_base]]) without providing a
generator.  This is allows the programmer to write a class or function
that uses random numbers without initializing its own private
generator (which in general is not desired as, among other things it
would introduce the need for several seeds) or requiring to receive a
reference or pointer to a generator as an argument.  In this way the
user of the class still gets to decide which generator will be used,
while keeping the interface simpler.  At present this is achieved with
a simple singleton mechanism, thus precluding the simultaneous use of
more than one generator.  A more flexible scope mechanism (similar to
that of the Environment classes) is planned but not yet implemented.

%'

<<random.hh>>=
#ifndef _RANDOM_HH_
#define _RANDOM_HH_

#include <fstream>
#include <map>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <boost/serialization/version.hpp>
#include <boost/serialization/binary_object.hpp>

#include <glsim/exception.hh>

namespace glsim {
<<generator declaration>>
<<distribution_base declaration>>
<<distribution_base inline methods>>
<<uniform_integer declaration>>
<<uniform_real declaration>>
<<gaussian_distribution delcaration>>
<<exponential_declaration>>
<<lognormal declaration>>
<<levy declaration>>
<<spherical3d declaration>>
}
<<out-of-namespace-declarations>>

#endif /* _RANDOM_HH_ */

<<random.cc>>=
#include <iostream>

#include <glsim/random.hh>

namespace glsim {
<<generator methods>>
<<static data>>
}

@ \subsection{Random number generator}

A GSL random number generator (RNG) is created by creating an instance
of this class.  Normally only one [[random_number_generator]] object
will exist, which can be shared among many random distributions.  The
internal state of a generator can be saved to a file and later
restored, with the simple interface or through Boost::serialize.  We
give here methods to access the raw generator output, but normally the
random numbers will be obtained through one of the distributions
defined below.

<<generator declaration>>=
class random_number_generator {
public:
  random_number_generator(const gsl_rng_type *type,const unsigned long seed=0,
			  const char* scope=default_scope);
  random_number_generator(random_number_generator&);
  random_number_generator& operator=(random_number_generator&);
  ~random_number_generator();
  void set_seed(const unsigned long seed);
  int save(FILE *f);
  int load(FILE *f);
  void save(std::ostream&);
  void load(std::istream&);

  unsigned long raw();
  unsigned long min() const;
  unsigned long max() const;
  unsigned long range() const;

  static const char* default_scope;

private:
  typedef std::map<std::string,gsl_rng*> genmap_t;
  typedef std::map<std::string,random_number_generator*> glsim_genmap_t;
  static genmap_t generator_map;
  static glsim_genmap_t glsim_generator_map;

  std::string      scope;
  gsl_rng          *generator;

  template<typename T> friend class random_distribution_base;
  // friend rdbase_ulong;
  // friend rdbase_double;

  template <typename Ar>
  void serialize(Ar& ar,const unsigned int version) const;
  friend class boost::serialization::access;
}  ;

@ The [[friend rdbase]] declarations above refer to
[[random_distribution_base]] specializations that are defined below.
The last friend is needed to give [[Boost::serialization]] acces to
the serialization functions.  We finish the declaration by setting the
class version number to keep track of changes for serialization.  This
declaration needs to be in the global namespace.

<<out-of-namespace-declarations>>=
BOOST_CLASS_VERSION(glsim::random_number_generator,0)


@ \paragraph{Implementation.}  Let us first define the static data.

<<static data>>=
const char* random_number_generator::default_scope="[default]";
random_number_generator::genmap_t random_number_generator::generator_map;
random_number_generator::glsim_genmap_t random_number_generator::glsim_generator_map;

@ Creation and destruction simply involve locating the corresponding
scope and eventually calling the corresponding [[gsl_rng]] functions.
Copying is complicated and not immediatly useful, not supported at
this time.

<<generator methods>>=
random_number_generator::
  random_number_generator(const gsl_rng_type *type,const unsigned long seed,
			  const char* scope_) :
  scope(scope_)
{
  if (generator_map.count(scope)==0)
    generator_map[scope]=gsl_rng_alloc(type);
  else throw glsim::Logic_error("Only one generator per scope is allowed");
  generator=generator_map[scope];
  glsim_generator_map[scope]=this;
}

random_number_generator::random_number_generator(random_number_generator& r)
{
  throw glsim::Unimplemented("copying of random number generator not allowed");
}

random_number_generator& 
random_number_generator::operator=(random_number_generator&)
{
  throw glsim::Unimplemented("copying of random number generator not allowed");
}

random_number_generator::~random_number_generator()
{
  gsl_rng_free(generator);
  generator_map.erase(scope);
  glsim_generator_map.erase(scope);
}

@ Setting the seed and saving/loading to file are immediate,
saving/loading to a stream are implemented by requesting a binary copy
of the generator state.

<<generator declaration>>=
inline void random_number_generator::set_seed(const unsigned long seed)
{
  gsl_rng_set(generator,seed);
}

inline int random_number_generator::save(FILE *f)
{
  return gsl_rng_fwrite(f,generator);
}

inline int random_number_generator::load(FILE *f)
{
  return gsl_rng_fread(f,generator);
}

<<generator methods>>=
void random_number_generator::save(std::ostream& os)
{
  void *state=gsl_rng_state(generator);
  os.write((char*) state,gsl_rng_size(generator));
}

void random_number_generator::load(std::istream& is)
{
  void *state=gsl_rng_state(generator);
  is.read((char*) state,gsl_rng_size(generator));
}

@ [[raw()]] returns an integer in the range [[[min()]],[[max()]]].

<<generator declaration>>=
inline unsigned long random_number_generator::raw()
{
  return gsl_rng_get(generator);
}

inline unsigned long random_number_generator::min() const
{
  return gsl_rng_min(generator);
}

inline unsigned long random_number_generator::max() const
{
  return gsl_rng_max(generator);
}

inline unsigned long random_number_generator::range() const
{
  return gsl_rng_max(generator)-gsl_rng_min(generator);
}

@ Finally, the serialization methods allow alternative interface to
state saving, through the Boost::serialization library.

<<generator declaration>>=
template <typename Ar>
void random_number_generator::serialize(Ar& ar,const unsigned int ver) const
{
  boost::serialization::binary_object bo(gsl_rng_state(generator),gsl_rng_size(generator));
  ar & bo;
}

@ \subsection{Random distributions}

The following classes provide random numbers distributed according to
different forms, based on the numbers provided by a
[[random_number_generator]] object.

The following is the base class for all distributions.  The way to
obtain a random number will be through [[operator()()]], which is pure
virtual at this level.  We provide access to the raw generator's
function here for convenience.

%'
<<distribution_base declaration>>=
template <typename ranT>
class random_distribution_base {
public:
  random_distribution_base(const char* scope=random_number_generator::default_scope);
  virtual ranT operator()()=0;

  unsigned long raw();
  unsigned long min() const;
  unsigned long max() const;
  unsigned long range() const;

protected:
  gsl_rng                 *generator;
  glsim::random_number_generator *glsim_generator;

private:
  std::string scope;
} ;

typedef random_distribution_base<double> rdbase_double;
typedef random_distribution_base<unsigned long> rdbase_ulong;

<<distribution_base inline methods>>=
template <typename ranT> inline random_distribution_base<ranT>::
random_distribution_base(const char* scope_) :
  scope(scope_)
{
  if (random_number_generator::generator_map.count(scope)==0)
    throw glsim::Invalid_operation("Random number distribution called without random_number_generator defined in scope "+scope);
  generator=random_number_generator::generator_map[scope];
  glsim_generator=random_number_generator::glsim_generator_map[scope];
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::raw()
{
  return glsim_generator->raw();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::min() const {
  return glsim_generator->min();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::max() const {
  return glsim_generator->max();
}

template <typename ranT>
unsigned long random_distribution_base<ranT>::range() const {
  return glsim_generator->range();
}


@ \subsubsection{Uniform random numbers}

These classes return real and integer random numbers with a uniform
distribution.  The first class represents uniformly-distributed
integer ([[unsigned long]]) numbers from 0 to a given integer.

<<uniform_integer declaration>>=
class uniform_integer : public rdbase_ulong {
public:
  uniform_integer(unsigned long default_m,const char* scope=
		  random_number_generator::default_scope);
  unsigned long operator()();
  unsigned long operator()(unsigned long m);

private:
  unsigned long default_m;
} ;

@ The range will be $[0,\ldots,m-1]$, where $m$ is specified as
argument or taken from the default specified on construction.

<<uniform_integer declaration>>=
inline
uniform_integer::uniform_integer(unsigned long m,const char *scope) :
  random_distribution_base(scope),
  default_m(m)
{}

inline unsigned long uniform_integer::operator()()
{
  return gsl_rng_uniform_int(generator,default_m);
}

inline unsigned long uniform_integer::operator()(unsigned long m)
{
  return gsl_rng_uniform_int(generator,m);
}

@ And now a uniformly-distributed real numbers in the range
$[a,b)$ ($b$ excluded).

<<uniform_real declaration>>=
class uniform_real : public rdbase_double {
public:
  uniform_real(double a=0,double b=1,const char *scope=random_number_generator::default_scope);
  double operator()();

private:
  double a,range;
} ;

inline uniform_real::uniform_real(double a,double b,const char* scope) :
  random_distribution_base(scope),
  a(a)
{
  range=b-a;
}

inline double uniform_real::operator()()
{
  return a+range*gsl_rng_uniform(generator);
}

@ \subsubsection{Gaussian distribution}

This class uses GSL RNG to return a real ([[double]]) distributed
according to
$$
p(x)\, dx = {1 \over \sqrt{2 \pi \sigma^2}} \exp (-x^2 / 2\sigma^2) \,dx.
$$


<<gaussian_distribution delcaration>>=
class gaussian_distribution : public rdbase_double {
public:
  gaussian_distribution(double sigma=1.,double mean=0.,
			const char* scope=random_number_generator::default_scope);
  double operator()();

private:
  double sigma,mean;
} ;

inline gaussian_distribution::gaussian_distribution(double sigma_,double mean_,
						    const char *scope) :
  random_distribution_base(scope),
  sigma(sigma_),
  mean(mean_)
{}

inline double gaussian_distribution::operator()()
{
  return mean + gsl_ran_gaussian(generator,sigma);
}

@ \subsubsection{Exponential distribution}

The exponential distribution is defined by
$$
          p(x)\, dx = {1 \over \mu} \exp(-x/\mu)\, dx.
$$

<<exponential_declaration>>=
class exponential_distribution : public random_distribution_base<double> {
public:
  exponential_distribution(double mu,
			   const char *scope=random_number_generator::default_scope);
  double operator()();

private:
  double mu;
} ;

inline
exponential_distribution::exponential_distribution(double mu_,const char *scope) :
  random_distribution_base(scope),
  mu(mu_)
{}

inline double exponential_distribution::operator()()
{
  return gsl_ran_exponential(generator,mu);
}

@ \subsubsection{Log-normal distribution}

The log-normal distribution is
$$
p(x)\, dx = {1 \over x \sqrt{2 \pi \sigma^2} } 
          \exp\left[-\frac{(\ln x - \zeta)^2}{2 \sigma^2}\right] \, dx.
$$

<<lognormal declaration>>=
class lognormal_distribution : public rdbase_double {
public:
  lognormal_distribution(double zeta,double sigma,
			 const char *scope=random_number_generator::default_scope);
  double operator()();

private:
  double zeta,sigma;
} ;

inline lognormal_distribution::lognormal_distribution(double zeta_,
						      double sigma_,
						      const char *scope) :
  random_distribution_base(scope),
  zeta(zeta_),
  sigma(sigma_)
{}

inline double lognormal_distribution::operator()()
{
  return gsl_ran_lognormal(generator,zeta,sigma);
}

@ \subsubsection{Levy distribution}

This distribution is defined by
$$
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c t|^\alpha).
$$

<<levy declaration>>=
class levy_distribution : public rdbase_double {
public:
  levy_distribution(double C,double alpha,
		    const char *scope=random_number_generator::default_scope);
  double operator()();

private:
  double C,alpha;
} ;

inline levy_distribution::levy_distribution(double C_,
					    double alpha_,
					    const char *scope) :
  random_distribution_base(scope),
  C(C_), alpha(alpha_)
{}

inline double levy_distribution::operator()()
{
  return gsl_ran_levy(generator,C,alpha);
}


@ \subsubsection{Spherical distribution}

This returns a random vector with tip on the unit sphere (random
direction in three dimensions).

<<spherical3d declaration>>=
class spherical3d_distribution : public rdbase_double {
public:
  spherical3d_distribution(const char *scope=random_number_generator::default_scope) :
  random_distribution_base(scope) {}

  double operator()();
  void operator()(double *r);
} ;


inline double spherical3d_distribution::operator()()
{
  throw glsim::Invalid_operation("operator() requires 3 arguments in spherical3d_distribution");
}

inline void spherical3d_distribution::operator()(double *r)
{
  gsl_ran_dir_3d(generator,r,r+1,r+2);
}
