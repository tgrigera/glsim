% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% environment.nw -- base class for Environment hierarchy
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013, 2014
% by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.
%'

@ \chapter{Environment}

The concept of environment is one of the major abstractions of the
library, and in this chapter we give the classes that represent it.

By our definition, there should be an Environment class to match any
Simulation class.  The Environment class corresponding to a given
Simulation must hold \emph{all} the data needed to perform the
simulation.  The [[Parameters]] objects are meant to be used only to
initialize the environment, and not for storing data.  The environment
is endowed with method to allow saving to disk and restoring, while
the [[Parameters]] classes have no such capability.  This is
important, as the environment can evolve during the simulation (see
the method [[step()]] below.)

The parts of the environment essential for the simulation should be
represented by an object of a type derived from [[class]]
[[SimEnvironment]] below.  However, observables (which see), which
will require a part of the environment to store their internal data,
are designed to be used as ``plug-ins'', and thus it is inconvenient
to require that all the environment be in a single object.  Rather we
allow to define several objects, belonging to several hierarchies
(descending from [[Environment]]), which will consolidate with each
other through a mechanism similar to the singleton construction, so
that saving and restoring can be done through a single object, as
required by the simulation.  To allow for several independent
environments to coexist (as is useful for instance in parallel
simulations), environments will be consolidated only if they belong to
the same \emph{scope,} labeled with a string and defined at the time
the object is created.

The intended use of the hierarchy is as folows: for every simulation
to be created, there will be an object of a type derived from
[[SimEnvironment]].  Each of these would be in a different scope.
Plugin-like object such as observables will create private
environments (derived from Environment), in one of the scopes used
when creating the [[SimEnvironment]]s.  The simulation then will deal
with the [[SimEnvironment]]s only, and will call methods to
initialize, load, or save automatically all the consolidated
environments in the scope (in effect working conceptually as a single
environment).

We explain below how to correctly derive from [[Environment]] and how
the saving and restoring of environments can be controlled.

<<environment.hh>>=
#ifndef _ENVIRONMENT_HH_
#define _ENVIRONMENT_HH_

#include <string>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/version.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

#include <glsim/log.hh>
#include <glsim/parameters.hh>

namespace glsim {
<<Environment declaration>>
<<BaseEnvironment declaration>>
<<SBSimEnvironment declaration>>
<<Exceptions>>
}
<<out-of-namespace declarations>>

#endif /* _ENVIRONMENT_HH_ */

<<environment.cc>>=
#include <fstream>

#include <glsim/environment.hh>

namespace glsim {
<<Environment methods>>
<<BaseEnvironment methods>>
<<SBSimEnvironment methods>>
}

@ \section{Environment}

All environment types must be derived from this class.  This
implements the consolidation by scope name, and provides two functions
to build filenames according to the \glsim\ convention.
[[Environment]] is an abstract class because [[step()]] is a pure
virtual.

The environment constructor must accept a scope name (a string), but
must provide a default name to allow default construction.  The scope
name will be also passed to the accompanying [[Parameters]] object.

The constructor must initialize the object in a suitable default, but
\emph{must not} attempt to read any value from [[Parameters]]:
parameter parsing will be done only after all environment objects are
created.  Thus initialization from parameters must be provided with
separate [[init()]] methods, discussed further below.  Initialization
comes in two flavors: full initialization ([[init()]]), which rebuilds
the environment state from scratch, reading from the parameters object
(and thus file), and warm initialization, which means that the
environment is already initialized (typically, has been read from an
earlier simulation) but needs partial initialization to be prepared to
start a new simulation.  What exactly this means will depend on a
simulation, but for instance, in a Monte Carlo simulation warm
initialization would \emph{not} initialize the random number
generator, while it \emph{would} initialize the requested number of
steps.

The user of the library will derive at least one class from
[[BaseEnvironment]] below: that class has the full interface for
loading and saving complete scopes, and will be typically manged from
the simulation class or from the main program.  In principle, only one
object of this class per scope will be created.  Additionally and
optionally, one or more classes can be derived directly from
[[Environment]]: these will be the ``floating'' environments, which
will belong to the scope of one [[BaseEnvironment]] descendant, and
saving, loading and initialization will be managed from there.  For
this reason the initialization methods are kept protected at this
level.

<<Environment declaration>>=
class Environment {
public:
  Environment(const char* scope=Parameters::default_scope);
  virtual ~Environment();
  const char * const scope() const {return scope_name.c_str();}

protected:
  typedef boost::archive::binary_oarchive oarchive_t;
  typedef boost::archive::binary_iarchive iarchive_t;
  // typedef boost::archive::text_oarchive oarchive_t;
  // typedef boost::archive::text_iarchive iarchive_t;

  virtual void step_local() {}
  virtual void init_local();
  virtual void warm_init_local();

  void initial_filename(std::string& name,const std::string& prefix);
  void final_filename(std::string& name,const std::string& prefix);

  std::string scope_name;
  std::string ini_infix,fin_infix,extension;

private:
  Parameters par;

  typedef std::list<Environment*> scope_t;
  typedef std::map<std::string,scope_t> scopemap_t;
  static  scopemap_t scopes;
  
  friend class BaseEnvironment;
  virtual void vserial(iarchive_t &ar);
  virtual void vserial(oarchive_t &ar);
  friend class boost::serialization::access;
  template <typename Archive>
  void serialize(Archive &ar,const unsigned int version);
} ;

<<out-of-namespace declarations>>=
BOOST_CLASS_VERSION(glsim::Environment,0);

@ %@<<

\subsection{Creation, initialization and destruction}

The default constructor below adds the object to the list of
environments belonging to the specified scope.  This is managed with a
[[std::map]] object.  The destructor clears it from the list.

<<Environment methods>>=
Environment::scopemap_t  Environment::scopes;

Environment::Environment(const char* scope) : 
  scope_name(scope),
  ini_infix("+++"),
  fin_infix("xxx"),
  extension(".dat"),
  par(scope)
{
#ifdef DEBUG
  logs(debug) << "(DD) (Environment) Pushing to scope " << scope << " ("
	      << this << ")\n";
#endif
  scopes[scope_name].push_back(this);
}

Environment::~Environment()
{
  scopes[scope_name].remove(this);
}

@ Initialization: in this case there is no difference between full and
warm, so [[warm_init()]] just calls [[init()]. Note however that we
must be careful because [[init()]] and [[warm_init()]] are virtual.
At this level, it is correct to implement [[warm_init()]] by calling
[[init()]], but if we must avoid the virtual call mechanism (by
qualifying it with the class name), because otherwise way we would in
effect be invoking the [[init()]] of the \emph{derived} class, which
is not what we want.

Note also that [[ini_infix]] and [[fin_infix]] are expected from a
parameters object to be declared elsewhere.  Normally this would be a
[[StandardCL]] with the same scope, but you may provide otherwise.  If
you do not wish to use the filename creation functions just ignore
them, it is not an error if the infixes are not declared.

<<Environment methods>>=
void Environment::warm_init_local() {Environment::init_local();}

void Environment::init_local()
{
  if (par.count("initial_infix")>0)
      ini_infix=par.value("initial_infix").as<std::string>();
  if (par.count("final_infix")>0)
    fin_infix=par.value("final_infix").as<std::string>();
}

@ \subsection{Serialization}

\label{sec:init-seri}

Serialization is done with [[Boost::serialization]], thus a
[[serialize()]] function is needed.  However, to implement loading and
saving at the scope level, two other functions must be provided,
although they are one-liners.  The reason is that when saving a scope
the serialize functions will be called on references, which are not
handled by Boost (virtual functions are needed for serializing objects
from a base class reference, but the mechanism used by Boost employs
template functions, which cannot be virtual).  The functions
[[vserial]] below will simply call the correct serialize function, but
the \emph{must} be overridden (though written identically), otherwise
only the base part will be saved (see tutorial).

<<Environment declaration>>=
template <typename Archive>
inline void Environment::serialize(Archive &ar,const unsigned int version)
{
  ar & scope_name;
  ar & ini_infix;
  ar & fin_infix;
}

inline void Environment::vserial(oarchive_t &ar) {ar << *this;}
inline void Environment::vserial(iarchive_t &ar) {ar >> *this;}

@ \subsection{Filename building}

Finally, these methods can be used to build an initial and final
filenames.  If the first argument contains the string [["[AUTO]"]],
then it will be replaced with a name of the form
prefix+infix+extension.  The extension is [[.dat]] by default, but you
can change it initializing [[extension]] to something else in your
derived [[init()]] method.

<<Environment methods>>=
void Environment::initial_filename(std::string& name,
					const std::string& prefix)
{
  if (name!="[AUTO]") return;
  name=prefix+ini_infix+extension;
}

void Environment::final_filename(std::string& name,
				      const std::string& prefix)
{
  if (name!="[AUTO]") return;
  name=prefix+fin_infix+extension;
}


@ \section{BaseEnvironment}

This class is the base for simulation environments, i.e.\ environments
that can do loading, saving and initialization at the scope level.  We
thus store here the filenames for reading and writing, and implement
the scope-wide methods.  This class also stores information about the
number of steps completed so far ([[steps_completed]],
[[steps_in_run]], [[steps_in_stage]]) and the booleans to communicate
with [[Simulation::run()]]: [[run_completed]] and [[log_requested]].
These two however are not updated here, but in one of the specialized
environments below.  The local step method ([[step_local]]) just
counts the steps, the scope-wide [[step()]] calls [[step_local()]] for
all members of the scope.

<<BaseEnvironment declaration>>=
class BaseEnv_par : public Parameters {
public:
  BaseEnv_par(const char *scope=Parameters::default_scope);
} ;

class BaseEnvironment : public Environment {
public:
  BaseEnvironment(const char* scope=Parameters::default_scope);

  void parse(const char*filename);
  void init_base();
  void init();
  void warm_init();
  void step();
  void load();
  void save();

  std::string configuration_file_ini,configuration_file_fin;
  std::string environment_file_ini,environment_file_fin;
  std::string title;
  long        steps_completed,steps_in_run,steps_in_stage;
  bool        run_completed;

protected:
  void init_local();
  void warm_init_local();
  void step_local();

private:
  std::string configuration_file_prefix,environment_file_prefix;
  BaseEnv_par par;

  void init_local_common();

  friend class boost::serialization::access;
  template <typename Archive>
  void serialize(Archive &ar,const unsigned int version);
  virtual void vserial(iarchive_t &ar) {ar >> *this;}
  virtual void vserial(oarchive_t &ar) {ar << *this;}
} ;

<<out-of-namespace declarations>>=
BOOST_CLASS_VERSION(glsim::BaseEnvironment,0);

@ \subsection{Construction and initialization}

The constructor loads everything with suitable defaults.  For
initialization, we need first to write the corresponding parameters
constructor, which declares the parameters to Boost::program\_options.

<<BaseEnvironment declaration>>=
inline BaseEnvironment::BaseEnvironment(const char* scope) :
  Environment(scope),
  configuration_file_ini("[AUTO]"),
  configuration_file_fin("[AUTO]"),
  environment_file_ini("[AUTO]"),
  environment_file_fin("[AUTO]"),
  title("[untitled]"),
  steps_completed(0), steps_in_run(0),steps_in_stage(0),
  run_completed(false),
  configuration_file_prefix("conf"),
  environment_file_prefix("env"),
  par(scope)
{
}

<<BaseEnvironment methods>>=
BaseEnv_par::BaseEnv_par(const char* scope) :
  Parameters(scope)
{
  parm_file_options().add_options()
    ("initial_configuration_file",po::value<std::string>()->default_value("[AUTO]"),
     "file to read inital configuration, if [AUTO], generated from prefix and infix")
    ("final_configuration_file",po::value<std::string>()->default_value("[AUTO]"),
     "file to write final configuration, if [AUTO], generated from prefix and infix")
    ("initial_environment_file",po::value<std::string>()->default_value("[AUTO]"),
     "file to read inital environment, if [AUTO], generated from prefix and infix")
    ("final_environment_file",po::value<std::string>()->default_value("[AUTO]"),
     "file to write final environment, if [AUTO], generated from prefix and infix")
    ("configuration_file_prefix",po::value<std::string>()->default_value("conf"),
     "prefix to generate initial and final configuration filenames")
    ("environment_file_prefix",po::value<std::string>()->default_value("env"),
     "prefix to generate initial and final environment filenames")
    ("title",po::value<std::string>()->default_value("[untitled]"),"simulation title")
    ;
}

@ Now the (object-level) initialization functions.  The local
initizializtion is public because partial initialization is useful
when checking for a partially completed simulation.  Note that the
requirement to call the base class init functions is fulfilled.

<<BaseEnvironment methods>>=
void BaseEnvironment::init_base()
{
  BaseEnvironment::init_local();
}

void BaseEnvironment::warm_init_local()
{
  Environment::warm_init_local();
  init_local_common();
}

void BaseEnvironment::init_local()
{
  Environment::init_local();
  init_local_common();
  steps_completed=0;
}

void BaseEnvironment::init_local_common()
{
  run_completed=false;
  configuration_file_ini=par.value("initial_configuration_file").as<std::string>();
  configuration_file_fin=par.value("final_configuration_file").as<std::string>();
  environment_file_ini=par.value("initial_environment_file").as<std::string>();
  environment_file_fin=par.value("final_environment_file").as<std::string>();
  configuration_file_prefix=par.value("configuration_file_prefix").as<std::string>();
  environment_file_prefix=par.value("environment_file_prefix").as<std::string>();
  title=par.value("title").as<std::string>();

  initial_filename(configuration_file_ini,configuration_file_prefix);
  final_filename(configuration_file_fin,configuration_file_prefix);
  initial_filename(environment_file_ini,environment_file_prefix);
  final_filename(environment_file_fin,environment_file_prefix);

  steps_in_stage=0;
  steps_in_run=0;
  run_completed=false;
}

@ \subsection{The step}

The local step function keeps count of the number of steps.  This
function is typically overridden.  Although it can be called from the
child's [[step_local()]], it is better to replicate it to avoid
another function call.  Some environments included in \glsim\ override
this as a no-op and instead rely on the simulation itself (through the
[[run()]] method) to keep the step count.  This can be more efficient,
because [[BaseEnvironment::step()]] can be told not call no-ops at all
(TODO).

<<BaseEnvironment declaration>>=
inline void BaseEnvironment::step_local()
{
  steps_completed++;
  steps_in_run++;
  steps_in_stage++;
}

@ \subsection{Serialization}

<<BaseEnvironment declaration>>=
template <typename Archive>
inline void BaseEnvironment::serialize(Archive &ar,const unsigned int version)
{
  ar & boost::serialization::base_object<Environment>(*this);
  ar & configuration_file_ini & configuration_file_fin;
  ar & environment_file_ini & environment_file_fin;
  ar & configuration_file_prefix & environment_file_prefix;
  ar & title;
  ar & steps_completed & steps_in_run & steps_in_stage;
  ar & run_completed;
}

@ \subsection{Scope-level functions}

Parsing the scope is actually implemented in [[Parameters]].
Initialization of the scope simply involves going through the list of
environments and calling the corresponding methods.

<<BaseEnvironment methods>>=
void BaseEnvironment::init()
{
  scope_t& scope=scopes[scope_name];

  for (Environment* e : scope) e->init_local();
}

void BaseEnvironment::warm_init()
{
  scope_t& scope=scopes[scope_name];

  for (Environment* e : scope) e->warm_init_local();
}

void BaseEnvironment::parse(const char* file)
{
  par.parse(file);
}

void BaseEnvironment::step()
{
  scope_t& scope=scopes[scope_name];

  for (Environment* e : scope) e->step_local();
}

@ Loading and saving call the serialization methods after opening a
binary archive.  Note that serialization here is done with
\emph{objects} (actually, references) and not pointers.  Thus the
environments must be created \emph{before} loading.  This is usually
the case in the simulation use, but you may want some environments to
be created dynamically as they are read.  If you want this, create
them in a scope that is not shared by any [[BaseEnvironment]] object,
and do the serialization through pointers yourself.

<<BaseEnvironment methods>>=
void BaseEnvironment::save()
{
  std::ofstream os(environment_file_fin,std::ios::binary);
  if (!os.is_open())
    throw Open_file_error(environment_file_fin);
  oarchive_t oa(os);

  scope_t& scope=scopes[scope_name];
  scope_t::size_type nenv=scope.size();
  oa << nenv;
  for (Environment* e : scope)
    e->vserial(oa);
}

void BaseEnvironment::load()
{
  std::ifstream is(environment_file_ini,std::ios::binary);
  if (!is.is_open())
    throw Open_file_error(environment_file_ini);
  iarchive_t iar(is);

  scope_t& scope=scopes[scope_name];
  scope_t::size_type nenv;
  iar >> nenv;
  if (nenv!=scope.size())
    throw Environment_unreadable("Number of objects has changed (now "+
				 std::to_string(scope.size()) + ", in file "+
   				 std::to_string(nenv)+")",HERE);
  for (Environment* e : scope)
    e->vserial(iar);
}

@ Exception classes for problems with environment i/o.

<<Exceptions>>=
class Environment_unreadable : public glsim::Runtime_error {
public:
  explicit Environment_unreadable(const std::string& msg,
				  const Source_context &c=Source_context()) :
      Runtime_error("ERROR: cannot read environmet: "+msg,c) {}
  ~Environment_unreadable() throw() {}
} ;


@ \section{SBSimEnvironment}

This is the environment that will used by step-based simulations
(i.e.\ those where the step is a meaningful time unit, and individual
runs are controlled by specifying the number of wanted steps).  We
store here the number of steps requested for this run
([[steps_requested]]), and the desired log and observation interval
([[log_interval]], [[obs_interval]]).

Note that [[step_local()]] is a noop.  This is because it is simple
enough that it is more efficiently carried out in
[[SBSimulation::run()]].  NOTE SOMEWHERE that run_completed MUST be
maintainted by someone.

<<SBSimEnvironment declaration>>=
class SBSimEnvironment_par : public Parameters {
public:
  SBSimEnvironment_par(const char* scope=Parameters::default_scope);
} ;

class SBSimEnvironment : public BaseEnvironment {
public:
  SBSimEnvironment(const char* scope=Parameters::default_scope);
  
  long  steps_requested;
  int   log_interval,obs_interval;

protected:
  void step_local() {}
  void init_local();
  void warm_init_local();

private:
  SBSimEnvironment_par par;

  friend class boost::serialization::access;
  template <typename Archive>
  void serialize(Archive &ar,const unsigned int version);
  virtual void vserial(iarchive_t &ar) {ar >> *this;}
  virtual void vserial(oarchive_t &ar) {ar << *this;}
} ;

<<out-of-namespace declarations>>=
BOOST_CLASS_VERSION(glsim::SBSimEnvironment,0);

<<SBSimEnvironment methods>>=
SBSimEnvironment_par::SBSimEnvironment_par(const char* scope) :
  Parameters(scope)
{
  parm_file_options().add_options()
    ("steps_requested",po::value<long>()->default_value(10),"requested steps")
    ("log_interval",po::value<int>()->default_value(0),
     "interval (in steps) to write logs (0=no logging)")
    ("obs_interval",po::value<int>()->default_value(0),
     "interval (in steps) to write observation (0=no observation)")
    ;
}

<<SBSimEnvironment declaration>>=
inline SBSimEnvironment::SBSimEnvironment(const char* scope) :
  BaseEnvironment(scope),
  steps_requested(0),
  log_interval(0),
  obs_interval(0),
  par(scope)
{}

template <typename Archive>
inline void SBSimEnvironment::serialize(Archive &ar,const unsigned int version)
{
  ar & boost::serialization::base_object<BaseEnvironment>(*this);
  ar & steps_requested & log_interval & obs_interval;
}

<<SBSimEnvironment methods>>=
void SBSimEnvironment::warm_init_local()
{
  BaseEnvironment::warm_init_local();
  steps_requested=par.value("steps_requested").as<long>();
  log_interval=par.value("log_interval").as<int>();
  obs_interval=par.value("obs_interval").as<int>();
}

void SBSimEnvironment::init_local()
{
  BaseEnvironment::init_local();
  steps_requested=par.value("steps_requested").as<long>();
  log_interval=par.value("log_interval").as<int>();
  obs_interval=par.value("obs_interval").as<int>();
}


@ \section{Continuous time environment}

Environment for continuous time simulations (i.e. where the ``real''
time, rather than the number of steps is the meaningful control
parameter for the span of the run).

<<ctenvironment.hh>>=
#ifndef _CTENVIRONMENT_HH_
#define _CTENVIRONMENT_HH_

#include <string>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/version.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

#include <glsim/environment.hh>

// namespace glsim {
// <<CTSBSimEnvironment declaration>>
// }
// <<out-of-namespace ct-declarations>>

#endif /* _CTENVIRONMENT_HH_ */

<<ctenvironment.cc>>=
#ifdef ufa
  
#include <glsim/ctenvironment.hh>

namespace glsim {
<<CTSBSimEnvironment methods>>
}

#endif /* ufa */

@ \paragraph{Declaration.}

<<CTSBSimEnvironment declaration>>=
class CTSBSimEnvironment_par : public Parameters {
public:
  CTSBSimEnvironment_par(const char* scope=Parameters::default_scope);
} ;

class CTSBSimEnvironment : public BaseEnvironment {
public:
  CTSBSimEnvironment(const char* scope=Parameters::default_scope);
  
  double  time_completed,time_in_run,time_requested;
  double  log_interval;
  int     max_steps;

protected:
  void step_local();
  void init_local();
  void warm_init_local();

private:
  CTSBSimEnvironment_par par;
  double               last_log_request;

  friend class boost::serialization::access;
  template <typename Archive>
  void serialize(Archive &ar,const unsigned int version);
  virtual void vserial(iarchive_t &ar) {ar >> *this;}
  virtual void vserial(oarchive_t &ar) {ar << *this;}
} ;

<<out-of-namespace ct-declarations>>=
BOOST_CLASS_VERSION(glsim::CTSBSimEnvironment,0);

@ \paragraph{Construction and serialization.}

<<CTSBSimEnvironment declaration>>=
inline CTSBSimEnvironment::CTSBSimEnvironment(const char* scope) :
  BaseEnvironment(scope),
  time_completed(0.), time_in_run(0.),
  time_requested(0.),
  log_interval(0.),
  max_steps(0),
  par(scope),
  last_log_request(0.)
{}

template <typename Archive>
inline void CTSBSimEnvironment::serialize(Archive &ar,const unsigned int version)
{
  ar & boost::serialization::base_object<SBSimEnvironment>(*this);
  ar & time_completed & time_in_run;
  ar & time_requested & log_interval;
  ar & max_steps & last_log_request;
}

@ \paragraph{Parameter definition and environment initialization.}

<<CTSBSimEnvironment methods>>=
CTSBSimEnvironment_par::CTSBSimEnvironment_par(const char* scope) :
  Parameters(scope)
{
  parm_file_options().add_options()
    ("time_requested",po::value<double>(),"time to reach in this run")
    ("max_steps",po::value<int>()->default_value(0),"if >0, maximum number of allowed simulation steps")
    ("log_interval",po::value<double>()->default_value(0.),
     "interval to log progress")
    ;
}

void CTSBSimEnvironment::warm_init_local()
{
  SBSimEnvironment::warm_init_local();
  time_requested=par.value("time_requested").as<double>();
  log_interval=par.value("log_time_step").as<double>();
  max_steps=par.value("max_steps").as<int>();

  time_in_run=0.;
}

void CTSBSimEnvironment::init_local()
{
  SBSimEnvironment::init_local();
  time_requested=par.value("time_requested").as<double>();
  log_interval=par.value("log_time_step").as<double>();
  max_steps=par.value("max_steps").as<int>();

  time_completed=0.;
  time_in_run=0.;
  last_log_request=0.;
}

@ \paragraph{Step.}

<<CTSBSimEnvironment declaration>>=
inline void CTSBSimEnvironment::step_local()
{
  steps_completed++;
  steps_in_run++;
  steps_in_stage++;
  log_requested = last_log_request + log_interval >= time_completed;
  if (log_requested) last_log_request=time_completed;
  run_completed = time_completed>=time_requested ||
    (max_steps>0 && steps_in_run>=max_steps);
}

