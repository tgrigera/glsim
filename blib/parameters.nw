% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% parameters.nw -- base class for Parameters hierarchy
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013, 2014
% by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.

@ \chapter{Parameters}

We provide here two classes, which correspond to our parameters
abstraction.  The library user will derive from here to define
parameters as needed as shown below.  The actual parsing is done
through Boost::program\_options.  One or more [[Parameters]]
descendants will be used to define the parameters to be read from a
parameter ([[.ini]]) file.  Typically, parameters will be defined at
several places, but parsing needs to be done only once all parameters
are defined (it is far easier to use Boost this way).  One can do this
by defining a single object from a type that is derived from
[[Parameters]].  It turns out however that it is much more convenient
to have different objects (descending from [[Parameters]] but of
different type), defined in places scattered all over the code, but
which share the [[.ini]] file.  Our solution is to define each
[[Parameters]] object with a \emph{scope} (designated by a string).
All [[Parameters]] objects defined within a scope will consolidate the
parameters information in one [[boost::program_options]] object, and
the parsing function will read all of them from a single file.
Different scopes should correspond to different files, if this
complexity is not needed, scoping can be ignored and a default scope
will be used.

To parse the command line, one can create an object derived from
[[ParametersCL]].  Only one such object should exist (but it can share
scope with other [[Parameters]]).  In this case two parser functions
must be called, one for the command line and one for the file (though
the second call can be automated, see [[ParametersCL]] below).  But
note that [[ParametersCL]] descends from [[Parameters]], thus it too
consolidates all parameter definitions. As result, if a
[[ParametersCL]] object exists, the parameters defined in other
[[Parameters]] objects in the same scope can also be specified as long
options in the command line, overriding the file values.

%'

<<parameters.hh>>=
#ifndef PARAMETERS_HH
#define PARAMETERS_HH

#include <string>
#include <iostream>
#include <map>
#include <boost/program_options.hpp>

#include <glsim/exception.hh>
#include <glsim/cerrors.h>

namespace glsim {
<<Parameters declaration>>
<<ParametersCL declaration>>
<<Exceptions>>
<<inline methods>>
<<Standard command line declaration>>
}

#endif /* PARAMETERS_HH */

<<parameters.cc>>=
#include <fstream>

#include "log.hh"
#include "parameters.hh"

namespace glsim {
<<static data>>
<<Parameters methods>>
<<ParametersCL methods>>
<<Standard command line methods>>
}

@ \section{Parameters}

To read parameters, the user declares a class inherited from
[[Parameters]].  The constructor of the derived class must declare
the parameters to be read by calling [[parm_file_options]], which is
an object of type [[options_description]] from
[[boost::program_options]].  See the example in [[test]] and the Boost
documentation for the declaration syntax.  Optionally, a scope can be
given when the object is created.  It is legal to define two objects
of the same class with different scopes.

To actually read the parameters from the file, one must call
[[Parameters::parse(char*)]] passing it a file name.  The parsing
should be done only once (in the simulation, from an [[Environent]]
object, which see).  After that, [[Parameters::count]] and
[[Parameters::value]] may be called to load parameters as desired.

The backend for parameter reading is Boost::program\_options.  Though
we allow that the parameter definition be scattered all over, the
definitios are actually collected in a single static object.  All the
parameters must be defined by the time the parser is called.  As a
result, the library user \emph{must not declary any global
  [[Parameter]] object,} or the static member objects may fail to be
properly initialized.

<<Parameters declaration>>=
namespace po=boost::program_options;

class Parameters {
public:
  static const char* default_scope;

  Parameters(const char* scope_=default_scope) : scope(scope_) {}
  void parse(const char *parfile);
  int  count(const std::string& s) const;
  const po::variable_value& value(const std::string& s) const;
  virtual void show_parameters(std::ostream&) const;
  
protected:
  po::options_description& parm_file_options();

private:
  typedef std::map<std::string,po::options_description> descmap_t;
  typedef std::map<std::string,po::variables_map> varmap_t;

  std::string      scope;
  static descmap_t description;
  static varmap_t  variables;

  friend class ParametersCL;
} ;

@ This is where the descriptions and values are stored.  To implement
scopes we simply use a [[std::map]].

<<static data>>=
const char* Parameters::default_scope="[default]";
Parameters::descmap_t Parameters::description;
Parameters::varmap_t  Parameters::variables;

@ To define the options, call this from the child's constructor to get
an [[options_description]] object from Boost.
%'

<<inline methods>>=
inline po::options_description& Parameters::parm_file_options()
{
  return description[scope];
}

@ The parse function just properly calls the Boost component.

<<Parameters methods>>=
void Parameters::parse(const char *parfile)
{
  po::store(po::parse_config_file<char>(parfile,parm_file_options()),
	    variables[scope]);
  po::notify(variables[scope]);
  glsim::logs(glsim::info) << "Parameters read from " << parfile << "\n";
}

@ With the next two methods one can retrieve the values of the
options. See the Boost documentation for usage of the
[[po::variable_value]] object.

<<Parameters methods>>=
const po::variable_value& Parameters::value(const std::string& s) const 
{
  if (variables.find(scope)==variables.end())
    throw Scope_not_parsed(scope);
  if (variables[scope].count(s)>0)
    return variables[scope][s];
  else
    throw Undefined_parameter(s);
}

<<inline methods>>=
inline int Parameters::count(const std::string& s) const
{
  if (variables.find(scope)==variables.end())
    throw glsim::Scope_not_parsed(scope);
  return variables[scope].count(s);
}

@ A help screen can be printed easily thanks to
[[boost::program_options]]' facilities.  Override if you prefer a
custom message. %'

<<Parameters methods>>=
void Parameters::show_parameters(std::ostream& o) const
{
  o << description[scope];
}

@ \paragraph{Exception.}  [[Parameters::value()]] will throw an
exception when an undefined parameter is requested.

<<Exceptions>>=
class Undefined_parameter : public glsim::Runtime_error {
public:
  explicit Undefined_parameter(const std::string& param,
			       const Source_context &c=Source_context()) :
  Runtime_error("ERROR: undefined parameter "+param,c) {}
  ~Undefined_parameter() throw() {}
} ;

class Scope_not_parsed : public glsim::Runtime_error {
public:
  explicit Scope_not_parsed(const std::string& scope,
			       const Source_context &c=Source_context()) :
    Runtime_error("ERROR: requested parameters before scope "+scope+" was parsed",c) {}
  ~Scope_not_parsed() throw() {}
} ;


@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{ParametersCL}

[[ParametersCL]] inherits from [[Parameters]], adding functionality to
parse a command line, always relying on [[boost::program_options]]'
facilities.  Only one [[ParametersCL]] object should be declared, and
it must \emph{not} be global. %'

This class is abstract because [[show_usage]] is a pure virtual.
Decent command-line parsing requires definition of ``positional
parameters'' (in Boost::program\_options jargon), and a good usage
message to match.  See the test section for an example.

<<ParametersCL declaration>>=
class ParametersCL : public Parameters {
public:
  ParametersCL(const char* scope=Parameters::default_scope);
  virtual void parse_command_line(int argc,char *argv[],bool require_parameter_file=true,
				  bool use_parameter_file=true);
  virtual void show_usage()=0;

protected:
  static po::options_description            command_line_options;
  static po::positional_options_description pos;
  std::string                               progname;
} ;			      

<<static data>>=
po::options_description            ParametersCL::command_line_options;
po::positional_options_description ParametersCL::pos;

@ The constructor declares three command-line options ([[--help]] or
[[-h]] to request usage help, [[--parameter-help]] to show all the
accepted parameters, and the optional [[parameter_file]] to name the
[[.ini]] file to be used).  The rest must be added by the user through
the [[command_line_options]] object.  Positional options can be
declared through the [[pos]] protected object, as documented in the
Boost library (see also the examples in the test section).

<<ParametersCL methods>>=
ParametersCL::ParametersCL(const char* scope) :
  Parameters(scope)
{
  command_line_options.add_options()
    ("help,h",po::bool_switch(),"help with usage")
    ("parameter-help",po::bool_switch(),"show accepted parameters")
    ("parameter_file",po::value<std::string>(),"specifiy parameter (.ini) file")
    ;
}

@ This method parses the command line and acts upon the help options,
displaying the requested help and throwing an exception.  Also, if
[[use_parameter_file]] is true and the [[control_file]] option is
given, the named file is parsed.  With [[require_parameter_file]], an
exception will be thrown if the parameter file is not given.  If this
behavior is not wanted, the method can be overriden.  To check for the
legality of the command line, in simple cases it will suffice to mark
some parameters as [[required()]].  In more complex cases a
[[parse_command_line]] can be written that calls this one to parse the
command line and then checks that all required command-line parameters
have been read and are consistent.

This method stores the program name in [[progname]] for the benefit of
[[show_usage]], if you override it be sure to initialize it also.

<<ParametersCL methods>>=
void ParametersCL::parse_command_line(int argc,char *argv[],bool require_parameter_file,
				      bool use_parameter_file)
{
  progname=basename(argv[0]);
  std::string parameter_file;

  try {

    command_line_options.add(parm_file_options());

    po::store(po::command_line_parser(argc,argv).options(command_line_options).
              positional(pos).run(),variables[scope]);
  
    if (value("help").as<bool>()) {
      show_usage();
      throw Early_stop();
    }
    if (value("parameter-help").as<bool>()) {
      show_parameters(std::cerr);
      throw Early_stop();
    }
    if (count("parameter_file")>0) {
      if (require_parameter_file || use_parameter_file)
	parameter_file=value("parameter_file").as<std::string>();
	parse(parameter_file.c_str());
    } else {
      if (!require_parameter_file) po::notify(variables[scope]);
      else throw Usage_error();
    }

  } catch (po::too_many_positional_options_error& e) {
    throw Usage_error();
  } catch (po::invalid_command_line_syntax& e) {
    throw Usage_error();
  } catch (po::invalid_command_line_style& e) {
    throw Usage_error();
  } catch (po::required_option& e) {
    throw Usage_error();
  } catch (po::reading_file& e) {
    throw Runtime_error("Cannot read parameter file "+parameter_file);
  }
}

@ \paragraph{Exceptions.}  In addition to [[Early_stop_required]],
[[ParametersCL]] can throw [[Usage_error]].  

<<Exceptions>>=
class Usage_error : public glsim::Runtime_error {
public:
  explicit Usage_error() :
  Runtime_error("usage error, try -h or --help",Source_context())
  {}
} ;


@ \section{The standard command line}

The following class is used to define standard command line for the
simulations distributed with \glsim.  It also serves as an additional
example use of [[ParametersCL]].  It is meant to use together with an
object of the [[Enviroment]] family (i.e. the (unique) [[StandardCL]]
object must be created after the [[Environmnet]]) and before it is
initialized.  If you want a different syntax for the command line you
can define another class to replace this, just be sure to add the
parameters defined in the constructor, either as command-line or
parameter-file options.  The parameters corresponding to the options
[[-c]], [[-i]], and [[-f]] below are only used in the STANDARD INIT???.

<<Standard command line declaration>>=
class StandardCL : public ParametersCL {
public:
  StandardCL(const char *scope=Parameters::default_scope);
  void show_usage();
} ;

<<Standard command line methods>>=
StandardCL::StandardCL(const char* scope) :
  ParametersCL(scope)
{
  command_line_options.add_options()
    ("initial_infix",po::value<std::string>()->required())
    ("final_infix",po::value<std::string>()->required())
    ("configuration-init,c",po::value<std::string>())
    ("ignore-partial-run,i",po::bool_switch())
    ("force-overwrite,f",po::bool_switch())
    ;
  pos.add("parameter_file",1).add("initial_infix",1).add("final_infix",1);
}

void StandardCL::show_usage()
{
  std::cerr << "usage: " << progname << " [options] parameter_file initial_infix final_infix\n\n"
    << "parameter_file is an ASCII file (.ini style) with the definition of the\n"
    << "simulation parameters.  initial_infix and final_infix will be used to form\n"
    << "the names of the input and output files (check the help for parameters\n"
    << "configuration_file_prefix) unless overridden by setting\n"
    << "initial_configuration_file, etc explicitly.\n\n"
    << "When starting from scratch, give +++ as initial_inifx to indicate that\n"
    << "configuration and environment must not be read from an earlier run.\n"
    << "In this case you may wish to give option -c below.\n\n"
    << "Options:\n"
    << "  -c,--configuration-init string\n"
    << "                          Will pass \"string\" to the Configuration\n"
    << "                          init method, to request inizialization of a default\n"
    << "                          configuration.  The string may be interpreted as\n"
    << "                          a filename.\n"
    << "  -f,--force-overwrite    Overwrite any eventual files with completed runs\n"
    << "  -i,--ignore-partial-run Ignore eventual files with partially completed runs\n"
    << "  -h,--help               Show this help\n"
    << "  --parameter-help        Show accepted parameters\n"
	 ;
}
