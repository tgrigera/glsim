% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% logging.nw - a simple log stream
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013 by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.
%
%'

@ \section{Logging}

Here we present a simple log stream class.  The idea is that [[main]]
will initialize the a global [[glsim::logs]] object (of type
[[glsim::logger]] with the desired verbosity level.  Applicaiton code
then writes to the log stream indicating the loglevel of the message as [[

     logs(glsim::info) << "Information message\n";

]]. To initialize the log stream, the main module must do two things
(see example in chapter XXXXREF):
\begin{enumerate}
\item Define a global object [[glsim::logger glsim::logs]].
\item Set the verbosity level and actual output stream with
  [[glsim::logs.set_stream(stream,loglevel)]].
\end{enumerate}
\textbf{NOT IMPLEMENTED} A second output stream can be set with
[[set_additional_stream]] (same syntax), possibly with a different
verbosity level.  This will result in some messages being copied to
both streams (depending on the levels).

<<log.hh>>=
#ifndef _LOGGING_HH_
#define _LOGGING_HH_

#include <iostream>

namespace glsim {

enum loglevel {debug=0, info=1, warn=2, error=3};

class logger {
public:
  logger();
  std::ostream& operator()(loglevel) const;

  logger& set_stream(std::ostream&,loglevel);
  logger& set_additional_stream(std::ostream&,loglevel);

private:
  struct {std::ostream* str; loglevel level;} stream1,stream2;
  std::ostream* logstream[4];
  std::ostream nullstream;
} ;

<<logger inline methods>>

extern logger logs;

} /* namespace */

#endif /* _LOGGING_HH_ */

@ The implementation is rather simple.  [[operator()]] simply returns
a reference to the actual stream that will do the output.  This stream
can be
\begin{enumerate}
\item an actual output stream such as [[std::cerr]] or a
  [[std::ofstream]] linked to a file,
\item a tee stream to implement writing to two sinks with just one
  insertion operator, or
\item a null stream that discards everything sent to it.
\end{enumerate}

The constructor initializes the logstream at the highest level and
outputing to [[std::cout]] (this should be changed by [[main()]]), and
sets up the null stream.  The easiest way to do the last appears to be
the trick suggested in StackOverflow
(http://stackoverflow.com/questions/6240950/platform-independent-dev-null-in-c/6240980#6240980):
define a [[std::ostream]] initialized with a null pointer.  This
creates a stream without a [[streambuf]] buffer, so that the stream is
left in an error state and never outputs anything (I also believe that
it skips all formatting, thus calls to the insertion operator should
be rather fast).

<<logger inline methods>>=
inline logger::logger() :
  nullstream(0)
{
  set_stream(std::cout,debug);
}

inline std::ostream& logger::operator()(loglevel l) const
{
  return *(logstream[l]);
}

@ To set the actual stream and loglevel we must store pointers to the
null stream or to the actual stream as appopriate in the [[logstream]]
array.  To allow simultaneous output to two streams we will have to
add an aditional ``tee'' stream (TODO).

<<log.cc>>=
#include "glsim/exception.hh"
#include "glsim/log.hh"

namespace glsim{

logger& logger::set_stream(std::ostream& str,loglevel level)
{
  stream1.str=&str;
  stream1.level=level;
  for (int i=0; i<level; i++)
    logstream[i]=&nullstream;
  for (int i=level; i<=error; i++)
    logstream[i]=stream1.str;

  return *this;
}

logger& logger::set_additional_stream(std::ostream&,loglevel)
{
  throw Unimplemented("set_additional_stream",HERE);

  return *this;
}

} /* namespace */


@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% How to build a tee stream
%
%
% From http://wordaligned.org/articles/cpp-streambufs (by Thomas
% Guest).
%

<<not used now>>=
#include <streambuf>

class teebuf: public std::streambuf
{
public:
    // Construct a streambuf which tees output to both input
    // streambufs.
    teebuf(std::streambuf * sb1, std::streambuf * sb2)
        : sb1(sb1)
        , sb2(sb2)
    {
    }
private:
    // This tee buffer has no buffer. So every character "overflows"
    // and can be put directly into the teed buffers.
    virtual int overflow(int c)
    {
        if (c == EOF)
        {
            return !EOF;
        }
        else
        {
            int const r1 = sb1->sputc(c);
            int const r2 = sb2->sputc(c);
            return r1 == EOF || r2 == EOF ? EOF : c;
        }
    }
    
    // Sync both teed buffers.
    virtual int sync()
    {
        int const r1 = sb1->pubsync();
        int const r2 = sb2->pubsync();
        return r1 == 0 && r2 == 0 ? 0 : -1;
    }   
private:
    std::streambuf * sb1;
    std::streambuf * sb2;
};

// Helper class

class teestream : public std::ostream
{
public:
    // Construct an ostream which tees output to the supplied
    // ostreams.
    teestream(std::ostream & o1, std::ostream & o2);
private:
    teebuf tbuf;
};

teestream::teestream(std::ostream & o1, std::ostream & o2)
  : std::ostream(&tbuf)
  , tbuf(o1.rdbuf(), o2.rdbuf())
{
}

// Usage

#include <fstream>
#include <iostream>
#include <teestream>

int main()
{
    std::ofstream log("hello-world.log");
    teestream tee(std::cout, log);
    tee << "Hello, world!\n";
    return 0;
}

// More generic version

template <typename char_type,
          typename traits = std::char_traits<char_type> >
class basic_teebuf:
    public std::basic_streambuf<char_type, traits>
{
public:
    typedef typename traits::int_type int_type;
    
    basic_teebuf(std::basic_streambuf<char_type, traits> * sb1,
                 std::basic_streambuf<char_type, traits> * sb2)
      : sb1(sb1)
      , sb2(sb2)
    {
    }
    
private:    
    virtual int sync()
    {
        int const r1 = sb1->pubsync();
        int const r2 = sb2->pubsync();
        return r1 == 0 && r2 == 0 ? 0 : -1;
    }
    
    virtual int_type overflow(int_type c)
    {
        int_type const eof = traits::eof();
        
        if (traits::eq_int_type(c, eof))
        {
            return traits::not_eof(c);
        }
        else
        {
            char_type const ch = traits::to_char_type(c);
            int_type const r1 = sb1->sputc(ch);
            int_type const r2 = sb2->sputc(ch);
            
            return
                traits::eq_int_type(r1, eof) ||
                traits::eq_int_type(r2, eof) ? eof : c;
        }
    }
    
private:
    std::basic_streambuf<char_type, traits> * sb1;
    std::basic_streambuf<char_type, traits> * sb2;
};

typedef basic_teebuf<char> teebuf;
