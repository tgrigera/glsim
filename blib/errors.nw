% -*- mode: Noweb; noweb-code-mode: c++-mode -*-
%
% errors.nw - error handling, debug aid and exception hierarchy
%
% This file is part of glsim, a numerical simulation class library and
% helper programs.
%
% glsim is copyright (C) 2009, 2010, 2011, 2012, 2013 by Tomas S. Grigera.
% 
% glsim is free software; you can redistribute it and/or modify it under
% the terms of the GNU General Public License (GPL) as published by the
% Free Software Foundation, with the additional requirements of
% attribution and nonmisrepresentation. You can use either version 3, or
% (at your option) any later version.
% 
% Additional terms under GNU GPL version 3 section 7:
% 
% When you redistribute this software, you are required to preserve its
% author attributions. If you distribute verbatim copies, you must not
% alter the AUTHORS file or attributions inserted in the source files,
% and you must not change the software's name. If you distribute a
% modified copy, then you must give clear notice that your work is
% different from but based on glsim. You must distribute it under a
% different name, but include a prominent notice specifying that "(your
% package) is based on glsim version x.x", and provide a pointer to the
% glsim distribution.
%
% glsim is distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
% or FITNESS FOR A PARTICULAR PURPOSE.
% 
% For details see the file LICENSE in the home directory. If the file is
% missing, contact the maintainers.
%
%'

@ \section{Error handling and debugging aid}

\subsection{Source context and backtrace}

We first define classes to aid in reporting source context (position
in a source file) and backtrace information.  This information is
included in the exceptions defined below, and can be printed when
catching the exception to aid debugging

<<scontext.hh>>=
#ifndef _SCONTEXT_HH
#define _SCONTEXT_HH

#include <execinfo.h>
#include <stdlib.h>

#include <iostream>
#include <sstream>

namespace glsim {
<<backtrace hdr>>
<<source context hdr>>
}

#endif /* _SCONTEXT_HH */

<<scontext.cc>>=
#include "scontext.hh"

<<backtrace code>>

@ \subsubsection{Backtrace}

The following class stores a backtrace, which can later be printed to
a stream with the overloaded insertion operator we provide.  See below
for a script to translate backtrace to function names and source line
numbers.  Note that compiling with debugging options and requesting
more detailed symbol tables in the executable (e.g.\ with [[-g]] and
[[-rsymbol]] in [[gcc]]) and will usually give richer backtrace
information (but in any case try processing with addr2line with the
aid of the script below).

<<backtrace hdr>>=
class Backtrace {
private:
  int              nptrs;
  static const int cbuffer_len = 100;
  void             *cbuffer[cbuffer_len];
  
public:
  Backtrace();

  friend std::ostream& operator<<(std::ostream&,const Backtrace&);
} ;

inline Backtrace::Backtrace()
{
  nptrs = backtrace(cbuffer,cbuffer_len);
}

<<backtrace code>>=
namespace glsim {

std::ostream& operator<<(std::ostream& o,const glsim::Backtrace& b)
{
  char **strings = backtrace_symbols(b.cbuffer, b.nptrs);
  o << "===== BACKTRACE START ==========\n";
  if (strings == 0)
    o << "ERROR: Failed to translate backtrace\n";
  else
    for (int j = 0; j < b.nptrs; j++)
      o << strings[j] << '\n';
  o << "===== BACKTRACE END ==========\n";
  free(strings);
  return o;
}

} /* namespace */

@ \paragraph{Interpreting the backtrace.}  This script exctracts the
backtrace produced by a program like [[context]] above, and processes
it with [[addr2line]] to translate the return addresses to source
lines and function names.  It can be run like this:

[[./progname 2>&1 | readbt.sh ./progname]]

(note that you must give [[progname]] again as an argument to
[[readbt.sh]].  Alternatively you can copy the programs output to a
file and redirect input to [[readbt.sh]] from that file.

<<readbt.sh>>=
#!/bin/bash
base=$(mktemp XXXXX)
rm -f $base
mkdir $base
csplit -s -z -f $base/xx - '%===== BACKTRACE START ==========%1' '/===== BACKTRACE END ==========/'
sed '/\[.*\]/ {s/.*\[\(.*\)\].*/\1/}' ${base}/xx00 | addr2line -C -e $1 -f -i
rm -rf ${base}



@ \subsubsection{Source context}
%$

The [[Source_context]] class holds source filename, line and function
information stored as a string.  It is intended mainly to be used with
the [[HERE]] macro to store local context (to report an error or throw
an exception).  It stores automatically a backtrace than can be
requested through the [[backtrace()]] method.  This feature is used by
the exceptions defined below.

<<source context hdr>>=
#define HERE glsim::Source_context(__FILE__,__LINE__,__func__)

class Source_context {
private:
  std::string desc_;
  Backtrace    bt;
  
public:
  Source_context(const char *FILE=0,int LINE=0,const char *func=0);
  const std::string& description() const {return desc_;}
  const Backtrace& backtrace() const {return bt;}
} ;
  
inline Source_context::Source_context(const char *FILE,int LINE,const char *func)
{
  if (FILE==0) {
    desc_="";
    return;
  }

  std::stringstream ss;
  ss << FILE << ':' << LINE;
  if (func) ss << " (" << func << ')';
  ss << ": ";
  desc_ = ss.str();
}

inline std::ostream& operator<<(std::ostream& o,const Source_context& c)
{
  o << c.description();
  return o;
}


@ \subsection{Exceptions}

Here we define the base exceptions for \glsim.  We create our own
[[Logic_error]] and [[Runtime_error]] exceptions that inherit
from the standard [[logic_error]] and [[runtime_error]] exceptions,
adding a [[Source_context]] argument.  These classes add the source
context description to the exception description argument (so that it
can be displayed through the [[what()]] method, plus another method
that gives access to the [[Backtrace]] object stored in
[[Source_context]].

<<exception.hh>>=
#ifndef _EXCEPTION_HH
#define _EXCEPTION_HH

#include <sstream>
#include <stdexcept>

#include <errno.h>
#include <string.h>

#include "glsim/scontext.hh"

namespace glsim {

  class Logic_error : public std::logic_error {
  private:
    const Source_context scontext;

  public:
    Logic_error(const std::string& desc,const Source_context &c=Source_context() ) :
      std::logic_error(c.description()+desc),
      scontext(c)
    {}
    const Backtrace &backtrace() const {return scontext.backtrace();}
    ~Logic_error() throw () {}
  } ;

  class Runtime_error : public std::runtime_error {
  private:
    const Source_context scontext;

  public:
    Runtime_error(const std::string& desc,const Source_context &c=Source_context() ) :
       std::runtime_error(c.description()+desc),
       scontext(c)
    {}
    const Backtrace &backtrace() const {return scontext.backtrace();}
    ~Runtime_error() throw () {}
  } ;

  <<exception hierarchy>>
}

#endif /* _EXCEPTION_HH */

@ \subsubsection{Exceptions deriving from [[Logic_error]].}

<<exception hierarchy>>=
class Unimplemented : public Logic_error {
public:
  explicit Unimplemented(const std::string& feature="unkown",
			 const Source_context &c=Source_context() ) :
    Logic_error("unimplemented: "+feature,c)
    {}
} ;

class Invalid_value : public Logic_error {
public:
  explicit Invalid_value(const std::string& value,const std::string& par,
			 const Source_context &c=Source_context() ) :
    Logic_error("invalid value ("+value+") for parameter "+par,c)
  {}
  ~Invalid_value() throw () {}
} ;


class Out_of_range : public Logic_error {
public:
  explicit Out_of_range(const Source_context &c=Source_context() ) :
    Logic_error("out of range",c) {}
  ~Out_of_range() throw () {}
} ;


@ \subsubsection{Exceptions deriving from [[Runtime_error]].}

<<exception hierarchy>>=
class Invalid_operation : public Runtime_error {
public:
  explicit Invalid_operation(const std::string& operation=std::string(),
			     const Source_context &c=Source_context()) :
    Runtime_error("invalid operation" + (operation.empty() ? "" : ": " + operation),
		  c)
  {}
} ;

class Open_file_error : public Runtime_error {
public:
  explicit Open_file_error(const std::string& file,
			   const Source_context &c=Source_context()) :
    Runtime_error("Cannot open "+file+": "+strerror(errno) )
  {}
} ;

class Clib_error : public Runtime_error {
public:
  explicit Clib_error(const Source_context &c=Source_context()) :
    Runtime_error(std::string("C library error: ") + strerror(errno), c)
    {}
} ;

@ The following is not actually an error, but a condition that
requires early stop.  It should be caught but not reported (i.e.\
[[what()]] not called).

<<exception hierarchy>>=
class Early_stop : public Runtime_error {
public:
  explicit Early_stop() :
    Runtime_error("Early stop",Source_context())
  {}
} ;


@ \subsection{Error reporting in C}

For the occasional C program we provide a simple way to abort the
program with a backtrace through the [[ERROR_EXIT]] and
[[SYSERROR_EXIT]] macros.  Also, the [[I_AM_HERE]] macro is provided
as an easy way to report source position (to stderr), useful when debugging.

<<cerrors.h>>=
#ifndef _CERRORS_H
#define _CERRORS_H

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>

#define ERROR_EXIT(s,ecode) \
        exit_on_error(__FILE__,__LINE__,__func__,s,ecode)

#define SYSERROR_EXIT(s,ecode) \
        exit_on_system_error(__FILE__,__LINE__,__func__,s,ecode)

#define I_AM_HERE \
  {fprintf(stderr,"(DD) Reached %s:%d (in function %s)\n",__FILE__,__LINE__, \
	  __func__); fflush(stderr); }

#ifdef _ERRORS_C
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef __cplusplus
#include <cstdio>
extern "C" {
#endif
EXTERN void exit_on_system_error(const char *file,int line,const char *func,
				 const char *s,int ecode);
EXTERN void exit_on_error(const char *file,int line,const char *func,
			  const char *s,int ecode);
#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _CERRORS_H */

<<cerrors.c>>=
#include <execinfo.h>
#define _ERRORS_C
#include "cerrors.h"

static char errbuf[2000];

static void print_backtrace_and_exit(int ecode)
{
  void   *ar[50];
  size_t n;

  n=backtrace(ar,50);
  fprintf(stderr,"===== BACKTRACE START ==========\n");
  backtrace_symbols_fd(ar,n,STDERR_FILENO);
  fprintf(stderr,"===== BACKTRACE END ==========\n");
  exit(ecode);
}

void exit_on_system_error(const char *file,int line,const char *func,
			  const char *s,int ecode)
{
  sprintf(errbuf,"%s:%d (%s): %s",file,line,func,s);
  perror(errbuf);
  print_backtrace_and_exit(ecode);
}

void exit_on_error(const char *file,int line,const char *func,
		   const char *s,int ecode)
{
  fprintf(stderr,"%s:%d (%s): %s\n",file,line,func,s);
  print_backtrace_and_exit(ecode);
}

